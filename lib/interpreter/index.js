const log = (res) => console.log(JSON.stringify(res, null, 2)) || res;

const interpreter = (frame) => {
  let heapPtr = 0;
  frame.stack = [];
  frame.heap = frame.heap || {};

  ////

  const refValue = (id) => {
    const ref = frame.heap[id];
    const { value } = ref ? frame.heap[ref] : {};
    if (value === undefined) return null;
    return value;
  };

  const derefValue = (id, slot) => {
    const ref = frame.heap[id];
    if (ref && frame.heap[ref].refCount) {
      frame.heap[ref].refCount--;
    }
    return ref;
  };

  const updateValueRef = (id, newValue, addRef) => {
    let valueRef = frame.heap[id] || `${id}.${heapPtr++}`;
    let { value = newValue, refCount } = frame.heap[valueRef] || {};
    frame.heap[id] = valueRef;

    // immediate value
    if (value !== undefined && !refCount) {
      frame.heap[valueRef] = {
        value: newValue === undefined ? value : newValue,
      };
    } else {
      if (refCount === undefined) {
        refCount = 1;
      } else if (addRef) {
        refCount++;
      } else if (refCount !== 1) {
        refCount = 1;
      }

      frame.heap[valueRef] = {
        value: newValue === undefined ? value : newValue,
        refCount,
      };
    }
    return valueRef;
  };

  const applyValue = (id, selector, slot, quantifier) => {
    const newRef = !derefValue(id);
    let value = undefined;
    if (quantifier) {
      value = newRef ? [] : refValue(id);
      value.push(refValue(selector));
    } else if (slot >= 0) {
      value = newRef ? [] : refValue(id);
      value[slot] = refValue(selector);
    }
    frame.heap[id] = updateValueRef(selector, value, newRef);
  };

  const applyArg = (id, arg, context) => {
    const newRef = !derefValue(id);
    frame.heap[id] = updateValueRef(id, context.args[arg], newRef);
  };

  const applyLiteral = (id, selector, slot, quantifier) => {
    const newRef = !derefValue(id);
    let value;
    if (quantifier) {
      value = newRef ? [] : refValue(id);
      value.push(selector);
    } else if (slot >= 0) {
      value = newRef ? [] : refValue(id);
      value[slot] = selector;
    } else {
      // selector generated by compiler
      value = selector;
    }
    frame.heap[id] = updateValueRef(id, value, newRef);
  };

  const popValue = (id) => {
    updateValueRef(id, frame.stack.pop());
  };

  const pushLiteral = (selector) => {
    frame.stack.push(selector);
  };

  const pushArg = (arg, { args = [] }) => {
    frame.stack.push(args[arg] === undefined ? null : args[arg]);
  };

  const pushValue = (selector) => {
    frame.stack.push(refValue(selector));
  };

  const call = (selector, temporalIdx, argCount, context) => {
    const args = frame.stack.slice(0 - argCount);
    frame.stack.splice(0 - argCount, argCount);
    callTemporal(selector, temporalIdx, {
      ...context,
      id: selector,
      recurse: {},
      args,
    });
    frame.stack.push(refValue(selector));
  };

  const callBinding = (selector, argCount) => {
    const args = frame.stack.slice(0 - argCount);
    frame.stack.splice(0 - argCount, argCount);
    const res = frame.bindings[selector].apply(null, args);
    frame.stack.push(res);
  };

  const callTemporal = (selector, temporalIdx, context) => {
    const rid = selector + temporalIdx;
    if (!context.recurse[rid]) {
      context.recurse[rid] = true;
      return run(frame.instructions[selector].temporal[temporalIdx], {
        ...context,
      });
    }
    context.idx = context.skip;
  };

  const skipIfTrue = (context) => {
    if (frame.stack.pop()) {
      context.idx = context.skip;
    }
  };

  const skipIfFalse = (context) => {
    if (frame.stack.pop() === false) {
      context.idx = context.skip;
    }
  };

  const execute = (
    { op, slot, quantifier, selector, temporalIdx, arg, argCount },
    context
  ) => {
    const { id } = context;
    switch (op) {
      case 'apply-value':
        return applyValue(id, selector, slot, quantifier);
      case 'apply-arg':
        return applyArg(id, arg, context, slot);
      case 'apply-block':
        return interpret(selector, { ...context, id: selector });
      case 'apply-literal':
        return applyLiteral(id, selector, slot, quantifier);
      case 'call':
        return call(selector, temporalIdx, argCount, context);
      case 'call-bind':
        return callBinding(selector, argCount);
      case 'call-temporal':
        return callTemporal(selector, temporalIdx, context);
      case 'skip-if-true':
        return skipIfTrue(context);
      case 'skip-if-false':
        return skipIfFalse(context);
      case 'pop-value':
        return popValue(id);
      case 'push-arg':
        return pushArg(arg, context);
      case 'push-value':
        return pushValue(selector);
      case 'push-literal':
        return pushLiteral(selector);
    }
  };

  const run = (instructions, context) => {
    context.skip = instructions ? instructions.length : 0;
    for (context.idx = 0; context.idx < context.skip; context.idx++) {
      execute(instructions[context.idx], context);
    }
  };

  const interpret = (id, context = { args: [], recurse: {}, id }) => {
    try {
      run(frame.instructions[id].immediate, context);
    } catch (err) {
      log(context);
      throw err;
    }
  };

  return (selector) => {
    const entry = frame.exports.includes(selector)
      ? [selector]
      : selector || frame.exports;
    const result = entry.reduce((acc, selector) => {
      interpret(selector);
      return { ...acc, [selector]: refValue(selector) };
    }, {});
    return selector ? result[selector] : result;
  };
};

module.exports = interpreter;
